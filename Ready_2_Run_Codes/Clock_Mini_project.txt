#include "msp430g2553.h"

unsigned char Hour_update=0,Min_update=0,Sec_update=0;
unsigned char Digit_Hour[2]={0};
unsigned char Digit_Min[2]={0};

const unsigned char Numeric[10]={~0x77,~0x41,~0x3B,~0x6B,~0x4D,~0x6E,~0x7E,~0x43,~0x7F,~0x6F};

void Display_time();
void Convert_Hour(unsigned char);
void Convert_Min(unsigned char);
void delay();
void config_switch();

void main()
{
 	WDTCTL = WDTPW + WDTHOLD;

 	unsigned int i=0;
 	P1DIR|=0xFF;            //To display values
 	P1OUT&=~0xFF;
 	P2DIR|=0xFF;            //To power the Segments[common cathode]
 	P2OUT|=0xFF;

    config_switch();


 	CCTL0 = CCIE;                             // CCR0 interrupt enabled
 	CCR0 =  32767;
 	TACTL = TASSEL_1 + MC_1+ ID_0;            // SMCLK, upmode

    __bis_SR_register(GIE);


	while(1)
	{
		for(i=0;i<200;i++)
		{
			delay();
			Display_time();
		}

	}
}



#pragma vector=TIMER0_A0_VECTOR
__interrupt void Timer_A (void)
{
	 Sec_update++;
	 if(Sec_update==60)
	 			 		  	{
	 			 		  		Sec_update=0;
	 			 		  		Min_update++;
	 			 		  		if(Min_update==60)
	 			 		  		{
	 			 		  			Min_update=0;
	 			 		  			Hour_update++;
	 			 		  			if(Hour_update==24)
	 			 		  			{
	 			 		  				Hour_update=0;
	 			 		  			}
	 			 		  		}
	 			 		  	}

}

#pragma vector=PORT2_VECTOR	   //Specify interrupt vector for Port1
__interrupt void GPIO(void)    //This is the interrupt service routine
{

				   //Clear the interrupt flag(no interrupt pending)
	               //Toggle Edge Select bit to prevent bounce effects
	if(P2IFG&BIT4)
	{
		P2IFG&=~BIT4;
		Hour_update++;
		if(Hour_update>23)
		{
			Hour_update=0;
		}
	}
	if(P2IFG&BIT5)
	{
		P2IFG&=~BIT5;
		Min_update++;
		if(Min_update>59)
		{
			Min_update=0;
		}

	}
}

void Display_time()
{
	Convert_Hour(Hour_update);
	Convert_Min(Min_update);

	P2OUT=BIT0;
	P1OUT=Numeric[Digit_Hour[0]];
	delay();

	P2OUT=BIT1;
	P1OUT=Numeric[Digit_Hour[1]];
	delay();

	P2OUT=BIT2;
	P1OUT=Numeric[Digit_Min[0]];
	delay();

	P2OUT=BIT3;
	P1OUT=Numeric[Digit_Min[1]];
	delay();

}


void Convert_Hour(unsigned char data)
{
	Digit_Hour[0]=data/10;
	Digit_Hour[1]=data%10;
}

void Convert_Min(unsigned char data)
{
	Digit_Min[0]=data/10;
	Digit_Min[1]=data%10;
}

void delay()
{
	__delay_cycles(2000);
}

void config_switch()
{
			P2DIR&=~(BIT4+BIT5);              //configure Port1-->pin3 as Input
	 	    P2REN|=(BIT4+BIT5);			   //Enable Pull_up/Pull_down register for Port1-->Pin3
	 	    P2OUT|=(BIT4+BIT5);			   //Select Pull_up mode for Port1-->Pin3

	 	    P2IE|=(BIT4+BIT5);                //Enable interrupt on Port1-->Pin3
	 	    P2IFG&=~(BIT4+BIT5);			   //Clear interrupt flag on Port1-->Pin3
	 	    P2IES|=(BIT4+BIT5);	             //Set Interrupt Edge Select on Port1-->Pin3
}


