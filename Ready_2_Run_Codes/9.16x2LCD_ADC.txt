#include  "msp430g2553.h"

#define mem1 (*(unsigned int*)0x244)
#define mem0 (*(unsigned int*)0x246)

float channel_0=0.0,channel_1=0.0; //connect tempr sensor to P1.0, heart_beat to P1.1

char input_0[4],input_1[4];

#define     LCM_DIR   P1DIR

#define     LCM_OUT   P1OUT


//
// Define symbolic LCM - MCU pin mappings
// We've set DATA PIN TO 4,5,6,7 for easy translation
//
#define     LCM_PIN_RS            BIT0          // P1.0
#define     LCM_PIN_EN            BIT1          // P1.1
#define     LCM_PIN_D7            BIT7          // P1.7
#define     LCM_PIN_D6            BIT6          // P1.6
#define     LCM_PIN_D5            BIT5          // P1.5
#define     LCM_PIN_D4            BIT4          // P1.4


#define     LCM_PIN_MASK  ((LCM_PIN_RS | LCM_PIN_EN | LCM_PIN_D7 | LCM_PIN_D6 | LCM_PIN_D5 | LCM_PIN_D4))

#define     FALSE                 0
#define     TRUE                  1

//
// Routine Desc:
//
// This is the function that must be called
// whenever the LCM needs to be told to
// scan it's data bus.
//
// Parameters:
//
//     void.
//
// Return
//
//     void.
//
void PulseLcm()
{
    //
    // pull EN bit low
    //
    LCM_OUT &= ~LCM_PIN_EN;
    __delay_cycles(200);

    //
    // pull EN bit high
    //
    LCM_OUT |= LCM_PIN_EN;
    __delay_cycles(200);

    //
    // pull EN bit low again
    //
    LCM_OUT &= (~LCM_PIN_EN);
    __delay_cycles(200);
}



//
// Routine Desc:
//
// Send a byte on the data bus in the 4 bit mode
// This requires sending the data in two chunks.
// The high nibble first and then the low nible
//
// Parameters:
//
//    ByteToSend - the single byte to send
//
//    IsData - set to TRUE if the byte is character data
//                  FALSE if its a command
//
// Return
//
//     void.
//
void SendByte(char ByteToSend, int IsData)
{
    //
    // clear out all pins
    //
    LCM_OUT &= (~LCM_PIN_MASK);
    //
    // set High Nibble (HN) -
    // usefulness of the identity mapping
    // apparent here. We can set the
    // DB7 - DB4 just by setting P1.7 - P1.4
    // using a simple assignment
    //
    LCM_OUT |= (ByteToSend & 0xF0);

    if (IsData == TRUE)
    {
        LCM_OUT |= LCM_PIN_RS;
    }
    else
    {
        LCM_OUT &= ~LCM_PIN_RS;
    }

    //
    // we've set up the input voltages to the LCM.
    // Now tell it to read them.
    //
    PulseLcm();
     //
    // set Low Nibble (LN) -
    // usefulness of the identity mapping
    // apparent here. We can set the
    // DB7 - DB4 just by setting P1.7 - P1.4
    // using a simple assignment
    //
    LCM_OUT &= (~LCM_PIN_MASK);
    LCM_OUT |= ((ByteToSend & 0x0F) << 4);

    if (IsData == TRUE)
    {
        LCM_OUT |= LCM_PIN_RS;
    }
    else
    {
        LCM_OUT &= ~LCM_PIN_RS;
    }

    //
    // we've set up the input voltages to the LCM.
    // Now tell it to read them.
    //
    PulseLcm();
}
void LcmSetCursorPosition(char Row, char Col)
{
    char address;

    //
    // construct address from (Row, Col) pair
    //
    if (Row == 0)
    {
        address = 0;
    }
    else
    {
        address = 0x40;
    }

    address |= Col;

    SendByte(0x80 | address, FALSE);
}



void ClearLcmScreen()
{
    //
    // Clear display, return home
    //
    SendByte(0x01, FALSE);
    SendByte(0x02, FALSE);
}

void InitializeLcm(void)
{
    //
    // set the MSP pin configurations
    // and bring them to low
    //
    LCM_DIR |= LCM_PIN_MASK;
    LCM_OUT &= ~(LCM_PIN_MASK);


    //
    // wait for the LCM to warm up and reach
    // active regions. Remember MSPs can power
    // up much faster than the LCM.
    //
    __delay_cycles(100000);


    //
    // initialize the LCM module
    //
    // 1. Set 4-bit input
    //
    LCM_OUT &= ~LCM_PIN_RS;
    LCM_OUT &= ~LCM_PIN_EN;

    LCM_OUT = 0x20;
    PulseLcm();

    //
    // set 4-bit input - second time.
    // (as reqd by the spec.)
    //
    SendByte(0x28, FALSE);

    //
    // 2. Display on, cursor on, blink cursor
    //
    SendByte(0x0E, FALSE);

    //
    // 3. Cursor move auto-increment
    //
    SendByte(0x06, FALSE);
}



void PrintStr(char *Text)
{
    char *c;

    c = Text;

    while ((c != 0) && (*c != 0))
    {
        SendByte(*c, TRUE);
        c++;
    }
}


///////////convert Function///////////
void convert_channel0(unsigned int value)
{
	unsigned int temp;
	temp=value/10;
	input_0[0]=temp+48;
	input_0[1]='.';
	temp=value%10;
	input_0[2]=temp+48;
	input_0[3]='\0';
}

void convert_channel1(unsigned int value)
{
	unsigned int temp;
	temp=value/10;
	input_1[0]=temp+48;
	input_1[1]='.';
	temp=value%10;
	input_1[2]=temp+48;
	input_1[3]='\0';
}


void main(void)
{
    WDTCTL = WDTPW + WDTHOLD;             // Stop watchdog timer

    InitializeLcm();
    ClearLcmScreen();
    ADC10CTL1 = INCH_1 + CONSEQ_3;            // A1/A0, repeat multi channel
    ADC10CTL0 = ADC10SHT_2 + MSC + ADC10ON + ADC10IE;
    ADC10AE0 = BIT0+BIT1;                          // P1.0,1 ADC option select
    ADC10DTC1 = 0x20;                         // 16 conversions

    for (;;)
      {
        ADC10CTL0 &= ~ENC;
        while (ADC10CTL1 & BUSY);               // Wait if ADC10 core is active
        ADC10SA = 0x244;                        // Data buffer start
        ADC10CTL0 |= ENC + ADC10SC;             // Sampling and conversion ready
        __bis_SR_register(CPUOFF + GIE);        // LPM0, ADC10_ISR will force exit
        channel_0=((float)mem0/1024)*3.3;
        channel_0=channel_0*10;
        convert_channel0(channel_0);
        channel_1=((float)mem1/1024)*3.3;
        channel_1=channel_0*10;
        convert_channel1(channel_1);

        SendByte (0x80, FALSE);
        PrintStr(input_0);
        SendByte (0xC0, FALSE);
        PrintStr(input_1);
        _NOP();                                 // space for debugger
        _NOP();                                 // Set Breakpoint here to read ADC
      }
}

#pragma vector=ADC10_VECTOR
__interrupt void ADC10_ISR (void)
{
  __bic_SR_register_on_exit(CPUOFF);        // Clear CPUOFF bit from 0(SR)
}



